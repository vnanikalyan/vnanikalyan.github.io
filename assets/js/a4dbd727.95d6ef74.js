"use strict";(self.webpackChunkvnanikalyan_github_io=self.webpackChunkvnanikalyan_github_io||[]).push([[3728],{5680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>p});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),g=o,p=d["".concat(l,".").concat(g)]||d[g]||m[g]||a;return n?r.createElement(p,s(s({ref:t},u),{},{components:n})):r.createElement(p,s({ref:t},u))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},6525:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=n(8168),o=(n(6540),n(5680));const a={slug:"Intro",id:"Intro",title:"Introduction",authors:["vnk"],tags:["NodeJs","Multi Threading"],custom_edit_url:null},s=void 0,i={unversionedId:"NodeJs/Multi-Threading/Intro",id:"NodeJs/Multi-Threading/Intro",title:"Introduction",description:"Multi-Threading in NodeJs can be acheived by the module - worker_threads",source:"@site/docs/NodeJs/Multi-Threading/Intro.md",sourceDirName:"NodeJs/Multi-Threading",slug:"/NodeJs/Multi-Threading/Intro",permalink:"/docs/NodeJs/Multi-Threading/Intro",draft:!1,editUrl:null,tags:[{label:"NodeJs",permalink:"/docs/tags/node-js"},{label:"Multi Threading",permalink:"/docs/tags/multi-threading"}],version:"current",frontMatter:{slug:"Intro",id:"Intro",title:"Introduction",authors:["vnk"],tags:["NodeJs","Multi Threading"],custom_edit_url:null},sidebar:"mySidebar",previous:{title:"Node Oracle DB",permalink:"/docs/NodeJs/CRUD-Series/node-oracle-db"},next:{title:"Using Jest",permalink:"/docs/NodeJs/unit-tests-jest"}},l={},c=[],u={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.yg)(d,(0,r.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Multi-Threading in NodeJs can be acheived by the module - ",(0,o.yg)("strong",{parentName:"p"},"worker_threads"),"\nThis module is one of the core Node Apis. We can run the synchronous tasks using this module."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Little Wisdom")),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Always run the threads equal to the number of the CPU Cores. "),(0,o.yg)("li",{parentName:"ol"},"Understand thread initialization overhead over parallelism. In some cases its better to run the tasks in main thread instead in worker as the thread initiation might cost more than saving the time complexity.")),(0,o.yg)("p",null,"The following is an example where we are calculating the sum of the given array elements using multi-threading"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-js"},"'use strict'\n\nconst { isMainThread, Workder, WorkerData, parentPort} = require('node:worker_threads')\nconst { eventEmitter } = require('node:events')\n\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter()\n\nlet sum = 0\n\nif(isMainThread) {\n    console.log('In Main Thread')\n\n    const worker = new Worker(__filename, {workerData: [1,2,3,4,5]})\n    console.log('worker.threadId - ', worker.threadId)\n    worker.on('message', message => {\n        console.log(message)\n        myEmitter.emit('message', Number(message))\n    })\n\n    //Second worker\n    const worker = new Worker(__filename, {workerData: [6,7,8,9,10]})\n    console.log('worker.threadId - ', worker.threadId)\n    worker.on('message', message => {\n        console.log(message)\n        myEmitter.emit('message', Number(message))\n    })\n\n    myEmitter.on('message', message => {\n        sum += message\n        console.log('sum - ', sum)\n    })\n    \n} else {\n    const sum = workderData.reduce((acc, val) => acc + val, 0)\n    parentPort.postMessage(sum)\n}\n\n")))}m.isMDXComponent=!0}}]);